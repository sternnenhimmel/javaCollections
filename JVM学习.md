# 深入理解JVM笔记整理
## 内存管理
### 内存模型
虚拟机栈（+本地方法栈）+程序计数器（很小，可忽略）+方法区（含常量池）+堆（用来存放各种动态变量以及所有用户自定义对象实例）+直接内存（NIO专用）
### 对象管理
对象创建：检测是否已加载，确定加载后进行内存分配和初始化
对象包含：对象头（元数据，即一些程序员不可见的隐含信息，如哈希，gc分代年龄，锁，偏向线程，对象长度等）+实例数据+对齐填充
访问定位：栈上只保存reference，指向句柄池（两个指针，指向实例和类）或者实例本身（实例数据+指向类的指针）
out of memory：堆溢出，栈溢出，直接内存溢出
### 垃圾收集
引用计数：无法解决循环依赖问题
可达性分析：从GC Root到当前对象的路径分析。可以被GC Root链接的对象有：栈上的对象，方法区中静态属性（即类变量）引用对象，方法区中常量引用对象，JNI中引用对象
引用类别：强引用，软引用，弱引用，虚引用（暂时想不到后面三种在实际中有什么用）
收集算法：标记清楚，复制算法（目前新生代较多），标记整理（老年代），分代收集（商用，默认eden：survival=8：1，其中，survival有两块，分别为from，to，轮流使用，新生：老年=1：1）
垃圾收集器：Serial，ParNew，Serial Old，Parrallel，CMS（目前商用比较多），G1（最近才成熟，适用于资源很大很多，任务很重的环境）
### 虚拟机监控工具
Jconsole, jps,jinfo什么的还是蛮好用的
## 执行系统
### Class类文件结构
类文件结构：（魔数+版本）+常量池+access flag+类、父类、接口索引+字段表+方法表；其中，字段表包括access flag, name index, descriptor index, attributes count和attributes；方法表结构和字段表相同，但属性和access flag的可选项不同
Code属性：attribute_name_index+attribute_length+max_stack+max_locals+code_length+code+exception_table_length+exception_table+attributes_count+attributes
指令集包含：加载存储（load，push，const，store），运算指令（add，div等），类型转换指令（i2c），对象创建和访问（newarray，new，laload等），操作数栈管理（dup，pop等），控制转移（ifXX，goto等），方法调用（invokeXXX），同步指令（mornitorXXX）
### 类加载机制
类的生命周期：加载+（验证，准备，解析）+初始化+使用+卸载
加载：用一个全限定名读进二进制字节流，转化为方法区的运行时数据结构，并生成一个Class对象
验证：文件格式验证（如魔数，版本，编码，类型等），元数据验证（如继承关系），字节码验证（分析文件流，进行逻辑合理性验证）
准备：在方法区分配内存，并进行初始化（只初始化常量，类变量在初始化阶段和构造函数一起进行初始化）
解析：把符号引用转变为直接引用（注意类或接口解析，字段解析，类方法解析，接口方法解析的过程）
初始化：<clinit>和<init>执行
类加载器：双亲委派模型
### 字节码执行引擎
运行时栈帧结构：局部变量表，操作数栈，动态连接，附加信息
方法调用：解析，分派（静态分派，动态分派，单分派，多分派，虚方法表
## 并发模型
### 并发的内存模型
并发内存模型：分为主内存和工作内存，java线程跑在工作内存上，是各自独立的空间，使用时需要从主内存拷贝需要的数据，而主内存则是存储了所有变量的地方。
主内存和工作内存的交互：(lock+unlock) read -> load -> use -> assign -> store -> write. 注意其中的规则
volatile的特殊规则：volatile对操作的连续性提出了更高的要求，从而保证了对所有线程实时可见并且一致。但是多个线程都要改写该变量时并不是线程安全的。
原子性（同步，原子操作），可见性（volatile），有序性（先行发生原则：程序次序，管程锁定，volatile原则等）
线程实现：内核线程，用户线程以及混合线程（利用操作系统的轻量级进程）
线程调度：抢占式和协同式（协程）调度
状态转换：新建，运行，无限等待，期限等待，阻塞，结束
### 线程安全与锁优化
java中的相对线程安全：单独进行操作是安全的，但对于一些特定顺序的连续调用，需要在调用端做一些同步措施，如Vector，HashTable，Collections，synchronizedCollection()方法包
线程安全的实现：1.加锁（synchronized）；2.依赖于硬件原子操作指令集的非阻塞同步；3.线程本地存储（保证一个变量由某个线程独享，java的一个请求对应一个线程模型）
锁优化：自旋，消除，粗化，轻量级锁偏向锁
## 程序编译及代码优化
编译前期：语法糖解析
编译后期优化：重要的有内联（很多其他优化算法的起点）和逃逸分析（激进优化，比较新）
